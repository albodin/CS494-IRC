using System;
using System.Linq;
using System.Net;
using System.Net.Security;
using System.Net.Sockets;
using System.Security.Authentication;
using System.Security.Cryptography.X509Certificates;
using System.Threading;

namespace IRC_Server
{
    class Program
    {
        /// <summary>
        /// Sets up the server to start listening for new connections
        /// </summary>
        public static void StartListening()
        {
            try
            {
                // Set up the local endpoint
                IPAddress ipAddress = IPAddress.Parse(Globals.Settings.ServerIp);
                IPEndPoint localEndPoint = new IPEndPoint(ipAddress, Globals.Settings.ServerPort);

                // Create the socket and begin accepting connections 
                Globals.Listener = new Socket(ipAddress.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
                Globals.Listener.Bind(localEndPoint);
                Globals.Listener.Listen(100);
                Globals.Listener.BeginAccept(ClientConnectCallback, null);

                Console.WriteLine($"Server is running on: {Globals.Settings.ServerIp}:{Globals.Settings.ServerPort}");
            }
            catch (Exception e)
            {
                Console.WriteLine($"Caught exception: {e.Message}");
            }
        }

        /// <summary>
        /// Runs on a new client connection, and sets a client id and adds to list of clients.
        /// </summary>
        /// <param name="asyncResult">Result from connection containing socket to client</param>
        public static void ClientConnectCallback(IAsyncResult asyncResult)
        {
            try
            {
                Socket clientSocket = Globals.Listener.EndAccept(asyncResult);

                NetworkStream networkStream = new NetworkStream(clientSocket);
                SslStream sslStream = new SslStream(networkStream, false);


                // Authenticate the server but don't require the client to authenticate.
                try
                {
                    sslStream.AuthenticateAsServer(Globals.ServerCertificate, false,
                        true);

                    // Display the properties and settings for the authenticated stream.
                    HelperMethods.DisplaySecurityLevel(sslStream);
                    HelperMethods.DisplaySecurityServices(sslStream);
                    HelperMethods.DisplayCertificateInformation(sslStream);
                    HelperMethods.DisplayStreamProperties(sslStream);

                    // Set timeouts to 5 seconds.
                    sslStream.ReadTimeout = 5000;
                    sslStream.WriteTimeout = 5000;
                }
                catch (AuthenticationException e)
                {
                    Console.WriteLine($"Exception: {e.Message}");
                    if (e.InnerException != null)
                    {
                        Console.WriteLine($"Inner exception: {e.InnerException.Message}");
                    }

                    Console.WriteLine("Authentication failed - closing the connection.");
                    sslStream.Close();
                    clientSocket.Close();
                    Globals.Listener.BeginAccept(ClientConnectCallback, null);// keep listening
                    return;
                }
                catch (Exception e)
                {
                    Console.WriteLine($"Exception: {e.Message}");
                    sslStream.Close();
                    clientSocket.Close();
                    Globals.Listener.BeginAccept(ClientConnectCallback, null);// keep listening
                    return;
                }


                byte[] clientId = new byte[10];
                Globals.Random.NextBytes(clientId);
                string idString = clientId.Aggregate("", (current, idByte) => current + idByte);

                // Keep trying until we get a username that isn't taken
                while (HelperMethods.UsernameTaken(idString))
                {
                    Globals.Random.NextBytes(clientId);
                    idString = clientId.Aggregate("", (current, idByte) => current + idByte);
                }

                ClientInfo newClient = new ClientInfo(clientSocket, sslStream, networkStream);
                newClient.SetUsername(idString);// Set the default username to the randomly generated byte id

                Globals.ClientList.Add(newClient);
                Console.WriteLine($"Client {newClient.GetUsername()} connected");
                newClient.BeginReceiveData();

                Globals.Listener.BeginAccept(ClientConnectCallback, null);
            }
            catch (ObjectDisposedException)
            {
                Console.WriteLine("ClientConnectCallback(): Object already disposed");
            }
            catch (SocketException se)
            {
                Console.WriteLine(se.Message);
            }
        }

        /// <summary>
        /// Handle setting changes
        /// </summary>
        public static void ChangeSettings()
        {
            bool settingsGood = false;
            while (!settingsGood)
            {
                Console.WriteLine("Your IPv4 addresses:");
                foreach (var ipAddress in HelperMethods.GetIpAddresses())
                {
                    Console.WriteLine(ipAddress);
                }

                Console.WriteLine("Current Settings:");
                Console.WriteLine($"1) Server IP: {Globals.Settings.ServerIp}");
                Console.WriteLine($"2) Server Port: {Globals.Settings.ServerPort}");
                Console.WriteLine($"3) Server Certificate Path: {Globals.Settings.ServerCertificatePath}");
                Console.WriteLine($"4) Server Certificate Password: {Globals.Settings.ServerCertificatePassword}");
                Console.WriteLine("Press RETURN to keep these settings or enter the number of which setting you wish to change and press RETURN");


                switch (Console.ReadLine())
                {
                    case "1":
                        Console.Write("Enter new server IP: ");
                        Globals.Settings.ServerIp = Console.ReadLine();
                        break;

                    case "2":
                        Console.Write("Enter new server port:");
                        string line = Console.ReadLine();
                        if (line != null && line.Trim() != "" && line.All(c => c >= '0' && c <= '9'))
                        {
                            Globals.Settings.ServerPort = int.Parse(line);
                        }
                        else
                        {
                            Console.WriteLine("You didn't enter a valid port. Port unchanged");
                        }
                        break;

                    case "3":
                        Console.Write("Enter new certificate path:");
                        Globals.Settings.ServerCertificatePath = Console.ReadLine();
                        break;

                    case "4":
                        Console.Write("Enter new certificate password:");
                        Globals.Settings.ServerCertificatePassword = Console.ReadLine();
                        break;

                    default:
                        settingsGood = true;
                        break;
                }

                try
                {
                    Globals.ServerCertificate = new X509Certificate2(Globals.Settings.ServerCertificatePath, Globals.Settings.ServerCertificatePassword);
                    IPAddress.Parse(Globals.Settings.ServerIp);
                }
                catch (Exception e)
                {
                    Console.WriteLine($"Exception: {e.Message}");
                    Console.WriteLine("Please fix your settings\n");
                    settingsGood = false;
                }
            }

        }

        /// <summary>
        /// Stops the server
        /// </summary>
        public static void StopServer()
        {
            HelperMethods.MessageAllClients(HelperMethods.FormatMessage(Headers.ServerDisconnecting));
            foreach (var client in Globals.ClientList)
            {
                // Spin while still sending
                while (client.IsSending()) { }

                // Now we can stop the client
                client.StopClient();
            }

            Globals.ClientList.Clear();
            Globals.ServerRooms.Clear();

            if (Globals.Listener != null)
            {
                if (Globals.Listener.Connected)
                {
                    Globals.Listener.Shutdown(SocketShutdown.Both);
                }
                Globals.Listener.Close();
            }
        }

        /// <summary>
        /// The main entry point for the application
        /// </summary>
        private static void Main()
        {
            var cancelKeyEvent = new ManualResetEvent(false);
            Console.CancelKeyPress += (sender, eventArgs) => {
                eventArgs.Cancel = true;
                cancelKeyEvent.Set();
            };

            ChangeSettings();
            StartListening();

            cancelKeyEvent.WaitOne();// Wait until cancel event
            
            //Now we clean up and exit
            StopServer();
        }
    }
}